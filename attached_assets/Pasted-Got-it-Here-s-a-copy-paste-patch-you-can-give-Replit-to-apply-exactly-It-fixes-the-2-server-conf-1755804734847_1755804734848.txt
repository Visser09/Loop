Got it. Here’s a copy-paste patch you can give Replit to apply exactly. It fixes:

the 2-server conflict (Vite on :5000 vs API on :3001),

the DB error when DATABASE_URL is missing,

and the confusing /api/login hit.

1) CineLoop/package.json — run a single server (Vite via middleware)

Replace your scripts with this:

{
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "vite build",
    "preview": "NODE_ENV=production tsx server/index.ts"
  }
}


This removes concurrently, dev:client, and dev:server.
Your existing server/index.ts already mounts Vite middleware in dev (setupVite(app, server)), so you should not run Vite separately.

Replit Run command:

cd CineLoop && npm run dev

2) CineLoop/server/replitAuth.ts — drop Passport/strategy, use a tiny header+dev shim

Replace the entire file with:

import type { Express, Response, NextFunction } from "express";

export async function setupAuth(app: Express) {
  app.use((req: any, _res: Response, next: NextFunction) => {
    const uid =
      req.get("X-Replit-User-Id") ||
      req.get("x-replit-user-id") ||
      (req.headers["x-replit-user-id"] as string | undefined);

    const uname =
      req.get("X-Replit-User-Name") ||
      req.get("x-replit-user-name") ||
      (req.headers["x-replit-user-name"] as string | undefined);

    if (uid && !req.user) {
      req.user = { claims: { sub: String(uid), username: uname || "replit" } };
    }
    next();
  });
}

export function isAuthenticated(req: any, res: Response, next: NextFunction) {
  if (req.user?.claims?.sub) return next();

  const auth = req.get("Authorization");
  if (auth && auth.startsWith("Bearer ") && auth.slice(7).trim().toUpperCase() === "DEV") {
    req.user = { claims: { sub: "dev-user", username: "dev" } };
    return next();
  }

  if (process.env.NODE_ENV !== "production") {
    req.user = { claims: { sub: "dev-user", username: "dev" } };
    return next();
  }

  return res.status(401).json({ message: "Unauthenticated" });
}

3) CineLoop/server/routes.ts — add health + no-DB safe path for /api/auth/user

Right after await setupAuth(app); add:

const hasDb = !!process.env.DATABASE_URL;
const hasTmdb = !!process.env.TMDB_API_KEY;

app.get("/api/health", (_req, res) => {
  res.json({
    status: "ok",
    env: process.env.NODE_ENV || "development",
    hasOpenAI: !!process.env.OPENAI_API_KEY,
    hasDb,
    hasTmdb,
  });
});

app.get("/api/login", (_req, res) => {
  res.status(405).json({ error: "Use GET /api/auth/user after auth. Login is handled upstream." });
});


Replace the entire /api/auth/user handler with this guarded version:

app.get('/api/auth/user', isAuthenticated, async (req: any, res) => {
  try {
    const userId = req.user.claims.sub;

    // NO DB? Return a synthetic user so the app loads,
    // and avoid calling storage.getUser (which triggers the Neon client).
    if (!hasDb) {
      return res.json({
        id: userId,
        username: req.user.claims.username || "dev",
        displayName: "Dev User",
        bio: "Local dev user (no DB)",
      });
    }

    const user = await storage.getUser(userId);
    res.json(user);
  } catch (error) {
    console.error("Error fetching user:", error);
    res.status(500).json({ message: "Failed to fetch user" });
  }
});


This is the key line that stops the NeonDbError when DATABASE_URL is not set.

(Optional but recommended) Make /api/feed safe without DB:

app.get('/api/feed', isAuthenticated, async (req: any, res) => {
  try {
    if (!hasDb) return res.json([]); // no DB -> empty feed
    const userId = req.user.claims.sub;
    const limit = parseInt(req.query.limit as string) || 20;
    const offset = parseInt(req.query.offset as string) || 0;
    const posts = await storage.getFeedPosts(userId, limit, offset);
    const enriched = await Promise.all(posts.map(async (post) => {
      const author = await storage.getUser(post.authorId);
      const title = await storage.getTitle(post.titleId);
      const userLike = await storage.getUserInteraction(userId, post.id, 'like');
      const userSave = await storage.getUserInteraction(userId, post.id, 'save');
      return { ...post, author, title, isLiked: !!userLike, isSaved: !!userSave };
    }));
    res.json(enriched);
  } catch (error) {
    console.error("Error fetching feed:", error);
    res.status(500).json({ message: "Failed to fetch feed" });
  }
});


Guard AI/TMDB endpoints (top of handlers):

// in /api/ai/chat and /api/ai/search:
if (!process.env.OPENAI_API_KEY) {
  return res.status(503).json({ message: "AI disabled in dev (missing OPENAI_API_KEY)" });
}

// in /api/search:
if (!hasTmdb) {
  if (!hasDb) return res.json([]);
  try {
    const q = String(req.query.q || "");
    const limit = parseInt(String(req.query.limit || 20));
    const local = await storage.searchTitles(q, limit);
    return res.json(local);
  } catch {
    return res.json([]);
  }
}

4) CineLoop/server/index.ts — leave as-is (single server)

You already:

log requests,

register routes,

mount Vite in dev,

and listen on process.env.PORT (defaults to 3001).

No changes needed here.

5) Replit Secrets (optional for dev; guarded now)

You won’t crash without them, but add when ready:

OPENAI_API_KEY

TMDB_API_KEY

DATABASE_URL

SESSION_SECRET

6) Sanity checks (Replit Shell)
# Should return JSON with status ok (no DB required)
curl -sS $REPLIT_APP_URL/api/health

# Should return a user object now (dev shim), with NO DB calls
curl -sS $REPLIT_APP_URL/api/auth/user

What this fixes in your logs

concurrently was still launching Vite on :5000 while your API served :3001 → confusing and unnecessary. We now run a single server; Vite is mounted in Express dev middleware.

/api/auth/user was calling storage.getUser even with DATABASE_URL unset → NeonDbError (ECONNREFUSED 127.0.0.1:443). The new handler short-circuits and returns a dev user when no DB, so no storage call happens.

/api/login now returns a helpful 405 instead of 404 and points you to /api/auth/user.

Hand that to Replit and you should see:

one server listening (e.g., serving on port 3001),

/api/health OK,

/api/auth/user returning the dev user,

no Neon connection attempts unless DATABASE_URL is set.